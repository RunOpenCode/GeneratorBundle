# Inject services into form types

Sometimes it will be necessary for you to injecting additional services
into generated form types.

GeneratorBundle registers all generated form types into service container
within bundle extension 
(see `\Admingenerator\GeneratorBundle\DependencyInjection\AdmingeneratorGeneratorExtension::registerFormsServicesFromGenerator()`
for implementation details).
 
Form types service names are generated according to the following pattern:
- For **NewType**: `admingen_generator_[UNDERSCORED_FORM_FQCN]_new`
- For **EditType**: `admingen_generator_[UNDERSCORED_FORM_FQCN]_new`
- For **FiltersType**: `admingen_generator_[UNDERSCORED_FORM_FQCN]_filter`

Illustrative example to understand service name pattern: if form type FQCN
is `\My\Example\Bundle\AdminEntity\Form\Type\NewType`, generated form type service name for new type
would be: `admingen_generator_my_examplebundle_adminentity_new`.

All auto-registered form type services contains proper service tag `form.type`, 
as well as setter definition which injects necessary `security.authorization_checker` 
service.

**BC NOTE:** *Up to version 2.2.2 service names were generated by using
model class name. As this would cause errors for multiple admins for one model type,
the new way is to use the bundle and admin prefix. However, 
in order not to inflict BC break, new service name patterns are aliased
with old service names. From version 3.0.0 this BC support will be removed,
you should use new service name pattern rule for referencing your form types
in service container.*

**BC NOTE:** *Up to version 2.1.1 service names were generated by using
only class name without namespaces. Considering our previous given example, 
generated service name would be `admingen_generator_entity_new`. This was
a bug in previous versions, which was fixed for versions above 2.1.1. However, 
in order not to inflict BC break, new service name patterns are aliased
with old service names. From version 3.0.0 this BC support will be removed,
you should use new service name pattern rule for referencing your form types
in service container.*

Now, when you are aware of the method of how generated form types are 
registered in service container, you are able to modify those service
definitions, and most common use case scenario is to inject additional 
dependencies.

Here are two proposed methods:

## Method 1: Create your own compiler pass and modify generated service definition

In your application bundle, you can register your own compiler pass, 
require your form type service definition and inject additional services, 
example:

    class MyAppCompilerPass implements CompilerPassInterface
    {
        public function process(ContainerBuilder $container)
        {
            if ($container->hasDefinition('admingen_generator_my_example_entity_new')) {
                $container
                    ->getDefinition('admingen_generator_my_example_entity_new')
                    ->setArguments( [ UTILIZING CONSTRUCTOR INJECTION ] )
                    ->addMethodCall( [ UTILIZING SETTER INJECTION ] );
            }
        }
    }

This is most preferable way, however, if you have a lot of forms for which
you have to modify service definitions, this can be time consuming.

## Method 2: "Magic" injection by using `runopencode\traitor-bundle` and traits
 
You can use third party bundle [`runopencode\traitor-bundle`](https://github.com/RunOpenCode/traitor-bundle)
which allows you to inject additional services to your auto-generated
forms with just `use trait` statement in form type class, and mentioned
bundle will take care of injecting appropriate service, example:
  
    namespace MyBundle\Form\Type\MyModel;
    
    use Admingenerated\MyBundle\Form\MyModelType\NewType as BaseNewType
    
    class NewType extends BaseNewType
    {
        use \Psr\Log\LoggerAwareTrait;
    }
    
In example given above, bundle will figure out that you are requiring for 
a `logger` service, which will be injected via setter injection.

This is very easy and productive way to inject additional services into
form types, you do not have to care about generated service names and you
do not have to create your own compiler pass, nor additionally code injection
logic.

However, it is a *"magic"* injection which breaks Symfony convention of
how service injection should be registered.

It is strongly advised to read fully and carefully documentation of 
`runopencode\traitor-bundle` before making decision of its usage, authors
have explained in details how bundle works, and what are *"pros"* and 
*"cons"* of its usage, so you can make informed decision and choose approach
which suits your needs best.



    
    